"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const loader_utils_1 = require("loader-utils");
const babel_core_1 = require("babel-core");
const better_babel_generator_1 = require("better-babel-generator");
const processAst_1 = require("./utils/processAst");
const constants_1 = require("../utils/constants");
const cannotRemoves = ['@tarojs/taro', 'react', 'nervjs'];
/**
 * @description use babel and processAst
 * @param source
 * @param ast
 */
function fileParseLoader(source, ast) {
    const { alias, buildAdapter, designWidth, deviceRatio, sourceDir } = loader_utils_1.getOptions(this);
    // console.log('fileParseLoader before:', source)
    const filePath = this.resourcePath;
    const newAst = babel_core_1.transformFromAst(ast, '', {
        plugins: [
            [require('babel-plugin-preval')],
            [require('babel-plugin-danger-remove-unused-import'), { ignore: cannotRemoves }]
        ]
    }).ast;
    const miniType = this._module.miniType || constants_1.PARSE_AST_TYPE.NORMAL;
    let resultAst;
    try {
        resultAst = processAst_1.processAst({
            ast: newAst,
            buildAdapter,
            type: miniType,
            designWidth,
            deviceRatio,
            sourceFilePath: filePath,
            sourceDir,
            alias
        });
    }
    catch (e) {
        console.log(e);
        throw e;
    }
    const code = better_babel_generator_1.default(resultAst).code;
    // if (miniType === PARSE_AST_TYPE.ENTRY) console.log('fileParseLoader', code)
    this.callback(null, code, resultAst);
    return code;
}
exports.default = fileParseLoader;
