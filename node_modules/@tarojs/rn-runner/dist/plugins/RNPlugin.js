"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("fs-extra");
const codeTransform_1 = require("../utils/codeTransform");
const SingleEntryDependency = require("webpack/lib/dependencies/SingleEntryDependency");
const FunctionModulePlugin = require("webpack/lib/FunctionModulePlugin");
const JsonpTemplatePlugin = require("webpack/lib/web/JsonpTemplatePlugin");
const NodeSourcePlugin = require("webpack/lib/node/NodeSourcePlugin");
const LoaderTargetPlugin = require("webpack/lib/LoaderTargetPlugin");
const lodash_1 = require("lodash");
const t = require("babel-types");
const babel_traverse_1 = require("babel-traverse");
const tapable_1 = require("tapable");
const _ = require("lodash");
const style_1 = require("../style");
const constants_1 = require("../utils/constants");
const utils_1 = require("../utils");
const TaroSingleEntryDependency_1 = require("../dependencies/TaroSingleEntryDependency");
// import { getTaroJsQuickAppComponentsPath } from '../utils/helper'
const parseAst_1 = require("../utils/parseAst");
const TaroLoadChunksPlugin_1 = require("./TaroLoadChunksPlugin");
const TaroNormalModulesPlugin_1 = require("./TaroNormalModulesPlugin");
const VirtualModulePlugin_1 = require("./VirtualModulePlugin/VirtualModulePlugin");
const chalk_1 = require("chalk");
const PLUGIN_NAME = 'RNPlugin';
let taroFileTypeMap = {};
let generateFileCache = {};
exports.createTarget = function createTarget(name) {
    return (compiler) => {
        const { options } = compiler;
        new JsonpTemplatePlugin().apply(compiler);
        new FunctionModulePlugin(options.output).apply(compiler);
        new NodeSourcePlugin(options.node).apply(compiler);
        new LoaderTargetPlugin('node').apply(compiler);
    };
};
exports.Targets = {
    ["weapp" /* WEAPP */]: exports.createTarget("weapp" /* WEAPP */),
    ["alipay" /* ALIPAY */]: exports.createTarget("alipay" /* ALIPAY */),
    ["swan" /* SWAN */]: exports.createTarget("swan" /* SWAN */),
    ["tt" /* TT */]: exports.createTarget("tt" /* TT */),
    ["qq" /* QQ */]: exports.createTarget("qq" /* QQ */),
    ["quickapp" /* QUICKAPP */]: exports.createTarget("quickapp" /* QUICKAPP */),
    ["rn" /* RN */]: exports.createTarget("rn" /* RN */)
};
function isFileToBeTaroComponent(code, sourcePath, buildAdapter) {
    try {
        const transformResult = codeTransform_1.getTransformResult({
            code,
            sourcePath: sourcePath
        });
        const { ast } = transformResult;
        let isTaroComponent = false;
        // @ts-ignore
        babel_traverse_1.default(ast, {
            ClassDeclaration(astPath) {
                astPath.traverse({
                    ClassMethod(astPath) {
                        if (astPath.get('key').isIdentifier({ name: 'render' })) {
                            astPath.traverse({
                                JSXElement() {
                                    isTaroComponent = true;
                                }
                            });
                        }
                    }
                });
            },
            ClassExpression(astPath) {
                astPath.traverse({
                    ClassMethod(astPath) {
                        if (astPath.get('key').isIdentifier({ name: 'render' })) {
                            astPath.traverse({
                                JSXElement() {
                                    isTaroComponent = true;
                                }
                            });
                        }
                    }
                });
            }
        });
        return {
            isTaroComponent,
            transformResult
        };
    }
    catch (error) {
        return error;
    }
}
exports.isFileToBeTaroComponent = isFileToBeTaroComponent;
class RNPlugin {
    constructor(options = {}) {
        this.tryAsync = fn => (arg, callback) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield fn(arg);
                callback();
            }
            catch (err) {
                callback(err);
            }
        });
        this.options = lodash_1.defaults(options || {}, {
            buildAdapter: "rn" /* RN */,
            nodeModulesPath: '',
            sourceDir: '',
            outputDir: '',
            designWidth: 750,
            commonChunks: ['runtime', 'vendors', 'taro', 'common'],
            isBuildPlugin: false,
            alias: {}
        });
        this.sourceDir = this.options.sourceDir;
        this.outputDir = this.options.outputDir;
        this.pages = new Set();
        this.components = new Set();
        this.pageConfigs = new Map();
        this.tabBarIcons = new Set();
        this.quickappStyleFiles = new Set();
        this.isWatch = false;
        this.errors = [];
        this.addedComponents = new Set();
    }
    apply(compiler) {
        this.context = compiler.context;
        this.appEntry = this.getAppEntry(compiler);
        // custom hooks
        compiler.hooks.getPages = new tapable_1.SyncHook(['pages']);
        // ÂºÄÂßãËØªÂèñ records ‰πãÂâçÔºåÈí©ÂÖ•(hook into) compiler„ÄÇ
        compiler.hooks.run.tapAsync(PLUGIN_NAME, this.tryAsync((compiler) => __awaiter(this, void 0, void 0, function* () {
            yield this.run(compiler);
        })));
        // ÁõëÂê¨Ê®°Âºè‰∏ãÔºå‰∏Ä‰∏™Êñ∞ÁöÑÁºñËØë(compilation)Ëß¶Âèë‰πãÂêéÔºåÊâßË°å‰∏Ä‰∏™Êèí‰ª∂Ôºå‰ΩÜÊòØÊòØÂú®ÂÆûÈôÖÁºñËØëÂºÄÂßã‰πãÂâç„ÄÇ
        compiler.hooks.watchRun.tapAsync(PLUGIN_NAME, this.tryAsync((compiler) => __awaiter(this, void 0, void 0, function* () {
            const changedFiles = this.getChangedFiles(compiler);
            if (!changedFiles.length) {
                yield this.run(compiler);
            }
            else {
                yield this.watchRun(compiler, changedFiles);
            }
        })));
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            compilation.hooks.finishModules.tap(PLUGIN_NAME, (modules) => {
                // console.log(modules)
            });
        });
        // ü§îÔ∏è ÁºñËØë(compilation)ÂàõÂª∫‰πãÂêéÔºåÊâßË°åÊèí‰ª∂„ÄÇ compilation.dependencyFactoriesÔºü
        compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, { normalModuleFactory }) => {
            compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
            compilation.dependencyFactories.set(TaroSingleEntryDependency_1.default, normalModuleFactory);
        });
        // ÁîüÊàêËµÑÊ∫êÂà∞ output ÁõÆÂΩï‰πãÂâç„ÄÇ
        compiler.hooks.emit.tapAsync(PLUGIN_NAME, this.tryAsync((compilation) => __awaiter(this, void 0, void 0, function* () {
            compilation.errors = compilation.errors.concat(this.errors);
            // genetate template styles json ÈÖçÁΩÆÂíå taroSelfComponents
            yield this.generateMiniFiles(compilation);
            yield this.generateStyleSheet(compilation);
            yield this.generateRNEntry(compilation);
            this.addedComponents.clear();
        })));
        // ÁîüÊàêËµÑÊ∫êÂà∞ output ÁõÆÂΩï‰πãÂêé„ÄÇ
        compiler.hooks.afterEmit.tapAsync(PLUGIN_NAME, this.tryAsync((compilation) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.addTarBarFilesToDependencies(compilation);
            }
            catch (e) {
                console.log(chalk_1.default.red(e));
            }
        })));
        new TaroLoadChunksPlugin_1.default({
            commonChunks: this.options.commonChunks,
            buildAdapter: this.options.buildAdapter,
            isBuildPlugin: this.options.isBuildPlugin,
            addChunkPages: this.options.addChunkPages
        }).apply(compiler);
        //ü§îÔ∏è TaroSingleEntryDependency Êò†Â∞ÑÂà∞ TaroNormalModule
        new TaroNormalModulesPlugin_1.default().apply(compiler);
    }
    getChangedFiles(compiler) {
        const { watchFileSystem } = compiler;
        const watcher = watchFileSystem.watcher || watchFileSystem.wfs.watcher;
        return Object.keys(watcher.mtimes);
    }
    getAppEntry(compiler) {
        const { entry } = compiler.options;
        if (this.options.isBuildPlugin) {
            const entryCopy = Object.assign({}, entry);
            compiler.options.entry = {};
            return entryCopy;
        }
        if (this.options.appEntry) {
            compiler.options.entry = {};
            return this.options.appEntry;
        }
        function getEntryPath(entry) {
            const app = entry['app'];
            if (Array.isArray(app)) {
                return app[0];
            }
            return app;
        }
        const appEntryPath = getEntryPath(entry);
        compiler.options.entry = {};
        return appEntryPath;
    }
    getNpmComponentRealPath(code, component, adapter) {
        let componentRealPath = null;
        let importExportName;
        // @ts-ignore
        const isTaroComponentRes = this.judgeFileToBeTaroComponent(code, component.path, adapter);
        if (isTaroComponentRes == null) {
            return null;
        }
        const { isTaroComponent, transformResult } = isTaroComponentRes;
        // @ts-ignore
        const isNativePageOrComponent = this.isNativePageOrComponent(this.getTemplatePath(component.path), fs.readFileSync(component.path).toString());
        if (isTaroComponent || isNativePageOrComponent) {
            return component.path;
        }
        // @ts-ignore
        const componentName = component.name.split('|')[1] || component.name;
        const { ast } = transformResult;
        babel_traverse_1.default(ast, {
            ExportNamedDeclaration(astPath) {
                const node = astPath.node;
                const specifiers = node.specifiers;
                const source = node.source;
                if (source && source.type === 'StringLiteral') {
                    specifiers.forEach(specifier => {
                        const exported = specifier.exported;
                        if (lodash_1.kebabCase(exported.name) === componentName) {
                            componentRealPath = utils_1.resolveScriptPath(path.resolve(path.dirname(component.path), source.value));
                        }
                    });
                }
                else {
                    specifiers.forEach(specifier => {
                        const exported = specifier.exported;
                        if (lodash_1.kebabCase(exported.name) === componentName) {
                            importExportName = exported.name;
                        }
                    });
                }
            },
            ExportDefaultDeclaration(astPath) {
                const node = astPath.node;
                const declaration = node.declaration;
                if (component.type === 'default') {
                    importExportName = declaration.name;
                }
            },
            CallExpression(astPath) {
                if (astPath.get('callee').isIdentifier({ name: 'require' })) {
                    const arg = astPath.get('arguments')[0];
                    if (t.isStringLiteral(arg.node)) {
                        componentRealPath = utils_1.resolveScriptPath(path.resolve(path.dirname(component.path), arg.node.value));
                    }
                }
            },
            Program: {
                exit(astPath) {
                    astPath.traverse({
                        ImportDeclaration(astPath) {
                            const node = astPath.node;
                            const specifiers = node.specifiers;
                            const source = node.source;
                            if (importExportName) {
                                specifiers.forEach(specifier => {
                                    const local = specifier.local;
                                    if (local.name === importExportName) {
                                        componentRealPath = utils_1.resolveScriptPath(path.resolve(path.dirname(component.path), source.value));
                                    }
                                });
                            }
                        }
                    });
                }
            }
        });
        if (componentRealPath) {
            component.path = componentRealPath;
            code = fs.readFileSync(componentRealPath).toString();
            componentRealPath = this.getNpmComponentRealPath(code, component, adapter);
        }
        return componentRealPath;
    }
    transformComponentsPath(filePath, components) {
        const { alias } = this.options;
        components.forEach(component => {
            try {
                let componentPath = component.path;
                let realComponentPath;
                if (componentPath) {
                    if (utils_1.isNpmPkg(componentPath)) {
                        if (utils_1.isAliasPath(componentPath, alias)) {
                            componentPath = utils_1.replaceAliasPath(filePath, componentPath, alias);
                            realComponentPath = utils_1.resolveScriptPath(path.resolve(filePath, '..', componentPath));
                        }
                        else {
                            realComponentPath = utils_1.resolveNpmSync(componentPath, this.options.nodeModulesPath);
                        }
                    }
                    else {
                        realComponentPath = utils_1.resolveScriptPath(path.resolve(filePath, '..', componentPath));
                    }
                    // const code = fs.readFileSync(realComponentPath).toString()
                    // const newComponent = Object.assign({}, component, {path: realComponentPath})
                    // realComponentPath = this.getNpmComponentRealPath(code, newComponent, buildAdapter)
                    component.path = realComponentPath;
                }
            }
            catch (error) {
                if (error.codeFrame) {
                    this.errors.push(new Error(error.message + '\n' + error.codeFrame));
                }
                else {
                    this.errors.push(error);
                }
            }
        });
    }
    getTabBarFiles(compiler, appConfig) {
        const tabBar = appConfig.tabBar;
        const { buildAdapter } = this.options;
        if (tabBar && typeof tabBar === 'object' && !utils_1.isEmptyObject(tabBar)) {
            const { list: listConfig, iconPath: pathConfig, selectedIconPath: selectedPathConfig } = constants_1.CONFIG_MAP[buildAdapter];
            const list = tabBar[listConfig] || [];
            list.forEach(item => {
                item[pathConfig] && this.tabBarIcons.add(item[pathConfig]);
                item[selectedPathConfig] && this.tabBarIcons.add(item[selectedPathConfig]);
            });
            if (tabBar.custom) {
                const customTabBarPath = path.join(this.sourceDir, 'custom-tab-bar');
                const customTabBarComponentPath = utils_1.resolveScriptPath(customTabBarPath);
                if (fs.existsSync(customTabBarComponentPath)) {
                    const customTabBarComponentTemplPath = this.getTemplatePath(customTabBarComponentPath);
                    const isNative = this.isNativePageOrComponent(customTabBarComponentTemplPath, fs.readFileSync(customTabBarComponentPath).toString());
                    if (!this.isWatch) {
                        utils_1.printLog("compile" /* COMPILE */, 'Ëá™ÂÆö‰πâ tabBar', this.getShowPath(customTabBarComponentPath));
                    }
                    const componentObj = {
                        name: 'custom-tab-bar/index',
                        path: customTabBarComponentPath,
                        isNative
                    };
                    this.components.add(componentObj);
                    this.getComponents(compiler, new Set([componentObj]), false);
                }
            }
        }
    }
    getSubPackages(appConfig) {
        const subPackages = appConfig.subPackages || appConfig['subpackages'];
        if (subPackages && subPackages.length) {
            subPackages.forEach(item => {
                if (item.pages && item.pages.length) {
                    const root = item.root;
                    item.pages.forEach(page => {
                        let pageItem = `${root}/${page}`;
                        pageItem = pageItem.replace(/\/{2,}/g, '/');
                        let hasPageIn = false;
                        this.pages.forEach(({ name }) => {
                            if (name === pageItem) {
                                hasPageIn = true;
                            }
                        });
                        if (!hasPageIn) {
                            const pagePath = utils_1.resolveScriptPath(path.join(this.sourceDir, pageItem));
                            const templatePath = this.getTemplatePath(pagePath);
                            const isNative = this.isNativePageOrComponent(templatePath, fs.readFileSync(pagePath).toString());
                            this.pages.add({
                                name: pageItem,
                                path: pagePath,
                                isNative
                            });
                        }
                    });
                }
            });
        }
    }
    getShowPath(filePath) {
        return filePath.replace(this.context, '').replace(/\\/g, '/').replace(/^\//, '');
    }
    getPages(compiler) {
        const { buildAdapter } = this.options;
        const appEntry = this.appEntry;
        const code = fs.readFileSync(appEntry).toString();
        try {
            const transformResult = codeTransform_1.getTransformResult({
                code,
                sourcePath: appEntry,
                sourceDir: this.sourceDir
            });
            // get appEntry configObj , inject pages , config
            // @ts-ignore
            const { configObj } = parseAst_1.default(transformResult.ast, buildAdapter);
            const appPages = configObj.pages;
            this.appConfig = configObj;
            if (!appPages || appPages.length === 0) {
                throw new Error('Áº∫Â∞ëÈ°µÈù¢');
            }
            if (!this.isWatch) {
                utils_1.printLog("compile" /* COMPILE */, 'ÂèëÁé∞ÂÖ•Âè£', this.getShowPath(appEntry));
            }
            this.getSubPackages(configObj);
            this.getTabBarFiles(compiler, configObj);
            // const template = ''
            taroFileTypeMap[this.appEntry] = {
                type: constants_1.PARSE_AST_TYPE.ENTRY,
                // config: configObj,
                // template,
                code: transformResult.code
            };
            this.pages = new Set([
                ...this.pages,
                ...appPages.map(item => {
                    const pagePath = utils_1.resolveScriptPath(path.join(this.sourceDir, item));
                    const pageTemplatePath = this.getTemplatePath(pagePath);
                    const isNative = this.isNativePageOrComponent(pageTemplatePath, fs.readFileSync(pagePath).toString());
                    return { name: item, path: pagePath, isNative };
                })
            ]);
            compiler.hooks.getPages.call(this.pages);
        }
        catch (error) {
            console.log(chalk_1.default.red('in getPages', error.stack));
            throw error;
            if (error.codeFrame) {
                this.errors.push(new Error(error.message + '\n' + error.codeFrame));
            }
            else {
                this.errors.push(error);
            }
        }
    }
    getPluginFiles(compiler) {
        const fileList = new Set();
        const { pluginConfig, buildAdapter } = this.options;
        let normalFiles = new Set();
        Object.keys(this.appEntry).forEach(key => {
            const filePath = this.appEntry[key][0];
            const code = fs.readFileSync(filePath).toString();
            const isTaroComponentRes = this.judgeFileToBeTaroComponent(code, filePath, buildAdapter);
            if (isTaroComponentRes == null) {
                return null;
            }
            if (isTaroComponentRes.isTaroComponent) {
                if (pluginConfig) {
                    fileList.add({
                        name: key,
                        path: filePath,
                        isNative: false
                    });
                    let isPage = false;
                    let isComponent = false;
                    Object.keys(pluginConfig).forEach(pluginKey => {
                        if (pluginKey === 'pages') {
                            Object.keys(pluginConfig[pluginKey]).forEach(pageKey => {
                                if (`plugin/${pluginConfig[pluginKey][pageKey]}` === key) {
                                    isPage = true;
                                }
                            });
                        }
                        if (pluginKey === 'publicComponents') {
                            Object.keys(pluginConfig[pluginKey]).forEach(pageKey => {
                                if (`plugin/${pluginConfig[pluginKey][pageKey]}` === key) {
                                    isComponent = true;
                                }
                            });
                        }
                    });
                    if (isPage) {
                        this.pages.add({
                            name: key,
                            path: filePath,
                            isNative: false
                        });
                        this.getComponents(compiler, fileList, isPage);
                    }
                    else if (isComponent) {
                        this.components.add({
                            name: key,
                            path: filePath,
                            isNative: false
                        });
                        this.getComponents(compiler, fileList, false);
                    }
                    else {
                        normalFiles.add({
                            name: key,
                            path: filePath,
                            isNative: true
                        });
                    }
                }
            }
        });
        normalFiles.forEach(item => {
            this.addEntry(compiler, item.path, item.name, constants_1.PARSE_AST_TYPE.NORMAL);
        });
        this.pages.forEach(item => {
            if (item.isNative) {
                this.addEntry(compiler, item.path, item.name, constants_1.PARSE_AST_TYPE.NORMAL);
            }
            else {
                this.addEntry(compiler, item.path, item.name, constants_1.PARSE_AST_TYPE.PAGE);
            }
        });
        // this.components.forEach(item => {
        //   if (item.isNative) {
        //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.NORMAL)
        //   } else {
        //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.COMPONENT)
        //   }
        // })
    }
    isNativePageOrComponent(templatePath, jsContent) {
        return fs.existsSync(templatePath) && jsContent.indexOf(constants_1.taroJsFramework) < 0;
    }
    getComponentName(componentPath) {
        return this.getRelativePath(componentPath)
            .replace(/\\/g, '/')
            .replace(path.extname(componentPath), '')
            .replace(/^(\/|\\)/, '');
    }
    getComponents(compiler, fileList, isRoot) {
        const { buildAdapter } = this.options;
        // const isQuickApp = buildAdapter === BUILD_TYPES.QUICKAPP
        fileList.forEach(file => {
            try {
                // const isNative = file.isNative
                // const isComponentConfig = isRoot ? {} : {component: true}
                let configObj;
                let taroSelfComponents;
                let depComponents;
                // let template
                let code = fs.readFileSync(file.path).toString();
                // get ast and components
                const transformResult = codeTransform_1.getTransformResult({
                    code,
                    sourcePath: file.path,
                    sourceDir: this.sourceDir,
                    isRoot
                });
                const { alias } = this.options;
                // replace alias to relative path
                transformResult.components = transformResult.components.map((item => {
                    if (utils_1.isAliasPath(item.path, alias)) {
                        item.path = utils_1.replaceAliasPath(file.path, item.path, alias);
                    }
                    return item;
                }));
                // console.log('RNPlugin getComponents',transformResult.components)
                transformResult.components = transformResult.components.filter((item) => !utils_1.isNpmPkg(item.path));
                // @ts-ignore
                let parseAstRes = parseAst_1.default(transformResult.ast, buildAdapter);
                configObj = parseAstRes.configObj;
                if (isRoot) {
                    const showPath = file.path.replace(this.sourceDir, '').replace(path.extname(file.path), '');
                    this.pageConfigs.set(showPath, configObj);
                }
                taroSelfComponents = parseAstRes.taroSelfComponents;
                const usingComponents = configObj.usingComponents;
                if (usingComponents) {
                    Object.keys(usingComponents).forEach(item => {
                        // @ts-ignore
                        transformResult.components.push({
                            name: item,
                            path: usingComponents[item]
                        });
                    });
                }
                if (isRoot) {
                    taroSelfComponents.add('taro-page');
                }
                depComponents = transformResult.components;
                // template = transformResult.template
                // code = transformResult.code
                depComponents = depComponents.filter(item => !/^plugin:\/\//.test(item.path));
                this.transformComponentsPath(file.path, depComponents);
                if (!this.isWatch) {
                    utils_1.printLog("compile" /* COMPILE */, isRoot ? 'ÂèëÁé∞È°µÈù¢' : 'ÂèëÁé∞ÁªÑ‰ª∂', this.getShowPath(file.path));
                }
                taroFileTypeMap[file.path] = {
                    type: isRoot ? constants_1.PARSE_AST_TYPE.PAGE : constants_1.PARSE_AST_TYPE.COMPONENT,
                    // config: merge({}, isComponentConfig, buildUsingComponents(file.path, this.sourceDir, alias, depComponents), configObj),
                    // template,
                    code
                };
                // if (depComponents && depComponents.length) {
                //   depComponents.forEach(item => {
                //     const componentPath = resolveScriptPath(path.resolve(path.dirname(file.path), item.path))
                //     if (fs.existsSync(componentPath) && !Array.from(this.components).some(item => item.path === componentPath)) {
                //       const componentName = this.getComponentName(componentPath)
                //       const componentTempPath = this.getTemplatePath(componentPath)
                //       const isNative = this.isNativePageOrComponent(componentTempPath, fs.readFileSync(componentPath).toString())
                //       const componentObj = {name: componentName, path: componentPath, isNative}
                //       this.components.add(componentObj)
                //       this.addedComponents.add(componentObj)
                //       this.getComponents(compiler, new Set([componentObj]), false)
                //     }
                //   })
                // }
            }
            catch (error) {
                console.log(chalk_1.default.red(error.stack));
                if (error.codeFrame) {
                    this.errors.push(new Error(error.message + '\n' + error.codeFrame));
                }
                else {
                    this.errors.push(error);
                }
            }
        });
    }
    addEntry(compiler, entryPath, entryName, entryType) {
        compiler.hooks.make.tapAsync(PLUGIN_NAME, (compilation, callback) => {
            const dep = new TaroSingleEntryDependency_1.default(entryPath, entryName, { name: entryName }, entryType);
            compilation.addEntry(this.sourceDir, dep, entryName, callback);
        });
    }
    addEntries(compiler) {
        this.addEntry(compiler, this.appEntry, 'app', constants_1.PARSE_AST_TYPE.ENTRY);
        this.pages.forEach(item => {
            if (item.isNative) {
                this.addEntry(compiler, item.path, item.name, constants_1.PARSE_AST_TYPE.NORMAL);
            }
            else {
                this.addEntry(compiler, item.path, item.name, constants_1.PARSE_AST_TYPE.PAGE);
            }
        });
        // this.components.forEach(item => {
        //   if (item.isNative) {
        //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.NORMAL)
        //   } else {
        //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.COMPONENT)
        //   }
        // })
    }
    generateMiniFiles(compilation) {
        return __awaiter(this, void 0, void 0, function* () {
            // const isQuickApp = buildAdapter === BUILD_TYPES.QUICKAPP
            const { modifyBuildTempFileContent, modifyBuildAssets } = this.options;
            if (typeof modifyBuildTempFileContent === 'function') {
                yield modifyBuildTempFileContent(taroFileTypeMap);
            }
            Object.keys(taroFileTypeMap).forEach(item => {
                // console.log('generateMiniFiles', taroFileTypeMap)
                const itemInfo = taroFileTypeMap[item];
                if (itemInfo.taroSelfComponents) {
                    itemInfo.taroSelfComponents.forEach(item => {
                        if (fs.existsSync(item.path)) {
                            const content = fs.readFileSync(item.path).toString();
                            const relativePath = this.getRelativePath(item.path).replace(/\\/g, '/');
                            compilation.assets[relativePath] = {
                                size: () => content.length,
                                source: () => content
                            };
                        }
                    });
                }
            });
            this.tabBarIcons.forEach(icon => {
                const iconPath = path.resolve(this.sourceDir, icon);
                if (fs.existsSync(iconPath)) {
                    const iconStat = fs.statSync(iconPath);
                    const iconSource = fs.readFileSync(iconPath);
                    compilation.assets[icon] = {
                        size: () => iconStat.size,
                        source: () => iconSource
                    };
                }
            });
            if (typeof modifyBuildAssets === 'function') {
                yield modifyBuildAssets(compilation.assets);
            }
        });
    }
    generateRNEntry(compilation) {
        const { appJson = {} } = this.options;
        const appJsonObject = Object.assign({
            name: _.camelCase(require(path.join(process.cwd(), 'package.json')).name)
        }, appJson);
        const indexJsCode = `
    import {AppRegistry} from 'react-native';
    import App from './app.js';
    import {name as appName} from './app.json';
    AppRegistry.registerComponent(appName, () => App);`;
        const indexJsonCode = JSON.stringify(appJsonObject, null, 2);
        const indexPath = 'index.js';
        const indexJsonPath = 'app.json';
        // cache
        if (generateFileCache[indexPath] && generateFileCache[indexPath].code === indexJsCode)
            return;
        generateFileCache[indexPath] = { code: indexJsCode };
        compilation.assets[indexPath] = {
            size: () => indexJsCode.length,
            source: () => indexJsCode
        };
        compilation.assets[indexJsonPath] = {
            size: () => indexJsonCode.length,
            source: () => indexJsonCode
        };
        utils_1.printLog("generate" /* GENERATE */, 'JSON', indexJsonPath);
        utils_1.printLog("generate" /* GENERATE */, 'JS', indexPath);
    }
    generateStyleSheet(compilation) {
        // emit ÊòØÂºÇÊ≠• hookÔºå‰ΩøÁî® tapAsync Ëß¶ÂèäÂÆÉÔºåËøòÂèØ‰ª•‰ΩøÁî® tapPromise/tap(ÂêåÊ≠•)
        // console.log('generateStyleSheet', compilation.assets)
        Object.keys(compilation.assets).forEach(fileName => {
            const fileInfo = compilation.assets[fileName];
            if (!constants_1.REG_STYLE.test(fileName))
                return;
            const relativePath = this.getRelativePath(fileName);
            // const extname = path.extname(fileName)
            // const styleSheetPath = relativePath.replace(extname, '_styles.js').replace(/\\/g, '/')
            const styleSheetPath = path.join(path.dirname(relativePath), 'index_styles.js');
            delete compilation.assets[fileName];
            const css = fileInfo.source();
            // cache
            if (generateFileCache[fileName] && generateFileCache[fileName].code === css)
                return;
            generateFileCache[fileName] = { code: css };
            const styleSheetSource = style_1.compileStyle(css, relativePath);
            compilation.assets[styleSheetPath] = {
                size: () => styleSheetSource.length,
                source: () => styleSheetSource
            };
        });
    }
    getRelativePath(filePath) {
        let relativePath;
        if (constants_1.NODE_MODULES_REG.test(filePath)) {
            relativePath = filePath.replace(this.options.nodeModulesPath, 'npm');
        }
        else {
            relativePath = filePath.replace(this.sourceDir, '');
        }
        return relativePath;
    }
    addTarBarFilesToDependencies(compilation) {
        const { fileDependencies } = compilation;
        this.tabBarIcons.forEach(icon => {
            if (!fileDependencies.has(icon)) {
                fileDependencies.add(icon);
            }
        });
    }
    transferFileContent(compiler) {
        Object.keys(taroFileTypeMap).forEach(item => {
            const itemInfo = taroFileTypeMap[item];
            if (typeof itemInfo.code === 'string') {
                new VirtualModulePlugin_1.default({
                    path: item,
                    contents: itemInfo.code
                }).apply(compiler);
            }
        });
    }
    judgeFileToBeTaroComponent(code, sourcePath, buildAdapter) {
        const isTaroComponentRes = isFileToBeTaroComponent(code, sourcePath, buildAdapter);
        if (isTaroComponentRes instanceof Error) {
            if (isTaroComponentRes.codeFrame) {
                this.errors.push(isTaroComponentRes);
            }
            else {
                this.errors.push(isTaroComponentRes);
            }
            return null;
        }
        return isTaroComponentRes;
    }
    run(compiler) {
        this.errors = [];
        if (!this.options.isBuildPlugin) {
            this.getPages(compiler);
            this.getComponents(compiler, this.pages, true);
            this.addEntries(compiler);
        }
        else {
            this.getPluginFiles(compiler);
        }
        this.transferFileContent(compiler);
    }
    watchRun(compiler, changedFiles) {
        const changedFile = changedFiles[0];
        utils_1.printLog("modify" /* MODIFY */, 'Êñá‰ª∂ÂèòÂä®', changedFile);
        this.isWatch = true;
        if (constants_1.REG_SCRIPTS.test(changedFile)) {
            this.changedFile = changedFile;
            let { type, obj } = this.getChangedFileInfo(changedFile);
            this.errors = [];
            if (!type) {
                const code = fs.readFileSync(changedFile).toString();
                const isTaroComponentRes = this.judgeFileToBeTaroComponent(code, changedFile, this.options.buildAdapter);
                if (isTaroComponentRes == null) {
                    return;
                }
                if (isTaroComponentRes.isTaroComponent) {
                    type = constants_1.PARSE_AST_TYPE.COMPONENT;
                    obj = {
                        name: changedFile.replace(this.sourceDir, '').replace(path.extname(changedFile), ''),
                        path: changedFile,
                        isNative: this.isNativePageOrComponent(this.getTemplatePath(changedFile), code)
                    };
                }
            }
            this.changedFileType = type;
            if (this.changedFileType === constants_1.PARSE_AST_TYPE.ENTRY
                || this.changedFileType === constants_1.PARSE_AST_TYPE.PAGE
                || this.changedFileType === constants_1.PARSE_AST_TYPE.COMPONENT) {
                // this.components.forEach(component => {
                //   if (component.path === changedFile) {
                //     this.components.delete(component)
                //   }
                // })
                if (this.changedFileType === constants_1.PARSE_AST_TYPE.ENTRY) {
                    this.run(compiler);
                }
                else {
                    if (!this.options.isBuildPlugin) {
                        this.getComponents(compiler, new Set([obj]), this.changedFileType === constants_1.PARSE_AST_TYPE.PAGE);
                        if (this.addedComponents.size) {
                            // this.addedComponents.forEach(item => {
                            //   if (item.isNative) {
                            //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.NORMAL)
                            //   } else {
                            //     this.addEntry(compiler, item.path, item.name, PARSE_AST_TYPE.COMPONENT)
                            //   }
                            // })
                        }
                    }
                    else {
                        this.getPluginFiles(compiler);
                    }
                    this.transferFileContent(compiler);
                }
                // if (obj && type === PARSE_AST_TYPE.COMPONENT && !this.components.has(obj)) {
                //   this.components.add(obj)
                // }
            }
        }
    }
    getChangedFileInfo(filePath) {
        let type;
        let obj;
        this.pages.forEach(page => {
            if (page.path === filePath) {
                type = constants_1.PARSE_AST_TYPE.PAGE;
                obj = page;
            }
        });
        // this.components.forEach(component => {
        //   if (component.path === filePath) {
        //     type = PARSE_AST_TYPE.COMPONENT
        //     obj = component
        //   }
        // })
        if (filePath === this.appEntry) {
            type = constants_1.PARSE_AST_TYPE.ENTRY;
        }
        return {
            type,
            obj
        };
    }
    getTargetFilePath(filePath, targetExtname) {
        const extname = path.extname(filePath);
        if (extname) {
            return filePath.replace(extname, targetExtname);
        }
        return filePath + targetExtname;
    }
    getTemplatePath(filePath) {
        return this.getTargetFilePath(filePath, constants_1.MINI_APP_FILES[this.options.buildAdapter].TEMPL);
    }
    getConfigPath(filePath) {
        return this.getTargetFilePath(filePath, constants_1.MINI_APP_FILES[this.options.buildAdapter].CONFIG);
    }
    getStylePath(filePath) {
        return this.getTargetFilePath(filePath, constants_1.MINI_APP_FILES[this.options.buildAdapter].STYLE);
    }
    static getTaroFileTypeMap() {
        return taroFileTypeMap;
    }
    static init() {
        taroFileTypeMap = {};
    }
}
exports.default = RNPlugin;
